#
#+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!
#                                                                       #
#                                 gis2gmsh.py                           # 
#                                                                       #
#+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!
#
# Author: Pat Prodanovic, Ph.D., P.Eng.
# 
# Date: June 29, 2015
#
# Purpose: Script takes in a text file of the geometry generated in qgis
# (or any other gis or cad package) and produces geometry files used by
# gmsh mesh generator program.
#
#
# Uses: Python2.7.9, Numpy v1.8.2
#
# Example:
#
# python gis2gmsh.py -n nodes.csv -b boundary.csv -l lines.csv -h holes.csv -o out.geo
#
# where:
#       --> -n is the file listing of all nodes (incl. embedded nodes
#                        if any). The nodes file consist of x,y,z or x,y,z,size;
#                        The size parameter is an optional input, and is used 
#                        by gmsh as an extra parameter that forces element 
#                        size around a particular node. The nodes file must
#                        be comma separated, and have no header lines. 
#
#       --> -b is the node listing of the outer boundary for the mesh.
#                        The boundary file is generated by snapping lines
#                        to the nodes from the nodes.csv file. The boundary file 
#                        consists of shapeid,x,y of all the lines in the file.
#                        Boundary has to be a closed shape, where first and last 
#                        nodes are identical. Shapeid is a integer, where the
#                        boundary is defined with a distict id (i.e., shapeid 
#                        of 0). 
#
#       --> -l is the node listing of the constraint lines for the mesh.
#                        The lines file can include open or closed polylines.
#                        The file listing has shapeid,x,y, where x,y have to 
#                        reasonable match that of the nodes.csv file. Each distinct
#                        line has to have an individual (integer) shapeid. If no 
#                        constraint lines in the mesh, enter 'none' without the quotes.
#
#       --> -h is the node listing of the holes in the mesh.
#                        The holes file must include closed polylines. The
#                        file listing has shapeid,x,y, where x,y have to reasonably
#                        match that of the nodes.csv file. Each distinct hole has to 
#                        have an individual (integer) shapeid. If no holes 
#                        (islands) in the mesh, enter 'none' without the quotes.
#
#      --> -o is the output gmsh geometry format. To generate the mesh, launch 
#                        gmsh and go to: Modules --> Mesh --> 2D
#
#      --> -d is an optional flag to ignore removal of duplicate nodes in the 
#                        nodes file. By default, duplicate nodes are removed 
#                        from the nodes.csv file. 
#                        
#                         
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Global Imports
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import os,sys                              # system parameters
import numpy             as np             # numpy
from collections import OrderedDict        # for removal of duplicate nodes
curdir = os.getcwd()
#
#
# I/O
if len(sys.argv) == 11 :
	dummy1 =  sys.argv[1]
	nodes_file = sys.argv[2]
	dummy2 =  sys.argv[3]
	boundary_file = sys.argv[4]
	dummy3 =  sys.argv[5]
	lines_file = sys.argv[6]
	dummy4 =  sys.argv[7]
	holes_file = sys.argv[8]
	dummy5 =  sys.argv[9]
	output_file = sys.argv[10]
	dummy6 = ' '
	duplicates_flag = 1 # removal of duplicate nodes is on by default
elif (len(sys.argv) == 13):
	dummy1 =  sys.argv[1]
	nodes_file = sys.argv[2]
	dummy2 =  sys.argv[3]
	boundary_file = sys.argv[4]
	dummy3 =  sys.argv[5]
	lines_file = sys.argv[6]
	dummy4 =  sys.argv[7]
	holes_file = sys.argv[8]
	dummy5 =  sys.argv[9]
	output_file = sys.argv[10]
	dummy6 = sys.argv[11]
	duplicates_flag = sys.argv[12]
else:
	print 'Wrong number of Arguments, stopping now...'
	print 'Usage:'
	print 'python gis2gmsh.py -n nodes.csv -b boundary.csv -l lines.csv -h holes.csv -o out.geo'
	#print 'or, if wanting to turn off duplicate removal algorithm'
	#print 'python gis2gmsh.py -n nodes.csv -b boundary.csv -l lines.csv -h holes.csv -o out.geo -d 0'
	sys.exit()

# find out if the nodes file is x,y,z or x,y,x,size
with open(nodes_file, 'r') as f:
    line = next(f) # read 1 line
    n_attr = len(line.split(','))

# to create the output file
fout = open(output_file,"w")

# use numpy to read the file
# each column in the file is a row in data read by no.loadtxt method
nodes_data = np.loadtxt(nodes_file, delimiter=',',skiprows=0,unpack=True)
boundary_data = np.loadtxt(boundary_file, delimiter=',',skiprows=0,unpack=True)

if (lines_file != 'none'):
	lines_data = np.loadtxt(lines_file, delimiter=',',skiprows=0,unpack=True)

if (holes_file != 'none'):
	holes_data = np.loadtxt(holes_file, delimiter=',',skiprows=0,unpack=True)

# master nodes in the file (from the nodes file)
x = nodes_data[0,:]
y = nodes_data[1,:]
z = nodes_data[2,:]
if (n_attr == 4):
	size = nodes_data[3,:]
else:
	size = np.zeros(len(x))

# n is the number of nodes
n = len(x)

# creates node numbers from the nodes file
node = np.zeros(n,dtype=np.int32)

# to check for duplicate nodes
# this piece of code uses OrderedDict to remove duplicate nodes
# source "http://stackoverflow.com/questions/12698987"
# ###################################################################
tmp = OrderedDict()
for point in zip(x, y, z, size):
  tmp.setdefault(point[:2], point)
mypoints = tmp.values()
# ###################################################################
n_rev = len(mypoints)

# replace x,y,z,size and n with their unique equivalents
if (duplicates_flag == 1):
	for i in range(n_rev):
		x[i] = mypoints[i][0]
		y[i] = mypoints[i][1]
		z[i] = mypoints[i][2]
		size[i] = mypoints[i][3]
	n = n_rev

# if node is part of boundary or lines, then it is not embedded
is_node_emb = np.zeros(n,dtype=np.int32)
for i in range(0,n):
	node[i] = i+1
	is_node_emb[i] = 1

# boundary data
shapeid_bnd = boundary_data[0,:]
x_bnd = boundary_data[1,:]
y_bnd = boundary_data[2,:]
# number of nodes in the boundary file
n_bnd = len(x_bnd)

# count lines from boundary lines
count_bnd = 0

# lines data
if (lines_file != 'none'):
	shapeid_lns = lines_data[0,:]
	x_lns = lines_data[1,:]
	y_lns = lines_data[2,:]
	# number of nodes in the lines file
	n_lns = len(x_lns)

# holes data
if (holes_file != 'none'):
	shapeid_hls = holes_data[0,:]
	x_hls = holes_data[1,:]
	y_hls = holes_data[2,:]
	# number of nodes in the holes file
	n_hls = len(x_hls)

count_lns = 0

# writes the nodes in gmsh format
for i in range(0,n):
	fout.write("Point(" + str(i+1) + ") = {" + str("{:.3f}".format(x[i])) +
		str(", ") + str("{:.3f}".format(y[i])) + str(", ") + 
		str("{:.3f}".format(z[i])) + str(", ") + str("{:.3f}".format(size[i])) + 
		str("};") + "\n")
	
# BOUNDARY LINES
# index of the minimum, for each boundary node
minidx = np.zeros(n_bnd,dtype=np.int32)
# distance between each boundary node and node in the master nodes file
# initialize to 999
xdist = np.add(np.zeros(n),999.0)
ydist = np.add(np.zeros(n),999.0)
dist = np.add(np.zeros(n),999.0)

for i in range(0,n_bnd):
	xdist = np.subtract(x,x_bnd[i])
	ydist = np.subtract(y,y_bnd[i])
	dist = np.sqrt(np.power(xdist,2.0) + np.power(ydist,2.0))
	#for j in range(0,n):
	#	dist[j] = np.sqrt(abs(x_bnd[i] - x[j])**2 + abs (y_bnd[i] - y[j])**2 )
	
	# find the minimum of the dist array
	minidx[i] = np.argmin(dist)
	#fout.write(str(i) + " " + str(minidx[i]) + "\n")
	
	# fill in the is_node_emb array 
	is_node_emb[minidx[i]] = 0
	
# write the boundary in gmsh format
for i in range(0,n_bnd-1):
	if (i == 0) :
		fout.write("Line(" + str(i+1) + str(") = {") + str(node[minidx[0]])
			+ str(", ") + str(node[minidx[1]]) + str("};") + "\n")
		count_bnd =count_bnd +1
	else:
		fout.write("Line(" + str(i+1) + str(") = {") + str(node[minidx[i]])
			+ str(", ") + str(node[minidx[i+1]]) + str("};") + "\n")
		count_bnd =count_bnd +1

# the lines numbering continues from the boundary numbering
count_lns = count_bnd + 1

# CONSTRAINT LINES
if (lines_file != 'none'):
	####################################
	# index for the minimum, for each lines node
	minidx_lns = np.zeros(n_lns,dtype=np.int32)
	# distance between each lines node and node in the master nodes file
	
	xdist_lns = np.add(np.zeros(n),999.0)
	ydist_lns = np.add(np.zeros(n),999.0)
	dist_lns = np.add(np.zeros(n),999.0)
	for i in range(0,n_lns):
		xdist_lns = np.subtract(x,x_lns[i])
		ydist_lns = np.subtract(y,y_lns[i])
		dist_lns = np.sqrt(np.power(xdist_lns,2.0) + np.power(ydist_lns,2.0))
		
		#for j in range(0,n):
		#	dist_lns[j] = np.sqrt(abs(x_lns[i] - x[j])**2 + abs (y_lns[i] - y[j])**2 )
		
		# find the minimum of the dist array
		minidx_lns[i] = np.argmin(dist_lns)
		#fout.write(str(i) + " " + str(minidx_lns[i]) + "\n")
		
		# fill in the is_node_emb array 
		is_node_emb[minidx_lns[i]] = 0
		
	cur_lns_shapeid = shapeid_lns[0]
	prev_lns_shapeid = shapeid_lns[0]	
	
	# write the constraint lines
	for i in range(0,n_lns):
		if (i>0):
			cur_lns_shapeid = shapeid_lns[i]
			prev_lns_shapeid = shapeid_lns[i-1]
			if (cur_lns_shapeid - prev_lns_shapeid < 0.001):
				#fout.write(str(cur_lns_shapeid) + " " + str(prev_lns_shapeid) + " ")
				fout.write("Line(" + str(count_lns) + str(") = {") + 
					str(node[minidx_lns[i-1]]) + str(", ") + str(node[minidx_lns[i]]) + str("};") + "\n")
				count_lns = count_lns + 1
	
####################################
# holes
count_hls = count_lns +1

hole_nodes = list()
if (holes_file != 'none'):
	# index for the minimum, for each lines node
	minidx_hls = np.zeros(n_hls,dtype=np.int32)
	# distance between each lines node and node in the master nodes file
	
	xdist_hls = np.add(np.zeros(n),999.0)
	ydist_hls = np.add(np.zeros(n),999.0)
	dist_hls = np.add(np.zeros(n),999.0)
	for i in range(0,n_hls):
		xdist_hls = np.subtract(x,x_hls[i])
		ydist_hls = np.subtract(y,y_hls[i])
		dist_hls = np.sqrt(np.power(xdist_hls,2.0) + np.power(ydist_hls,2.0))
		
		#for j in range(0,n):
		#	dist_hls[j] = np.sqrt(abs(x_hls[i] - x[j])**2 + abs (y_hls[i] - y[j])**2 )
		
		# find the minimum of the dist array
		minidx_hls[i] = np.argmin(dist_hls)
		#fout.write(str(i) + " " + str(minidx_hls[i]) + "\n")
		
		# fill in the is_node_emb array 
		is_node_emb[minidx_hls[i]] = 0
		
	cur_hls_shapeid = shapeid_hls[0]
	prev_hls_shapeid = shapeid_hls[0]	
	
	# write the constraint lines
	for i in range(0,n_hls):
		if (i>0):
			cur_hls_shapeid = shapeid_hls[i]
			prev_hls_shapeid = shapeid_hls[i-1]
			if (cur_hls_shapeid - prev_hls_shapeid < 0.001):
				#fout.write(str(cur_hls_shapeid) + " " + str(prev_hls_shapeid) + " ")
				hole_nodes.append(count_hls)
				fout.write("Line(" + str(count_hls) + str(") = {") + 
					str(node[minidx_hls[i-1]]) + str(", ") + str(node[minidx_hls[i]]) + str("};") + "\n")
				count_hls = count_hls + 1
	####################################

#fout.write("HOLES" + str(hole_nodes) + '\n')

n_holes = len(hole_nodes)

# writes the line loop and the plane surface
fout.write("Line Loop(1) = {1:"+ str(count_bnd))
if (holes_file != 'none'):
	fout.write(', ')
	for i in range(n_holes-1):
		fout.write(str(hole_nodes[i]*-1) + ", ")
	fout.write(str(-1*hole_nodes[n_holes-1]))	
fout.write(str("};") + "\n")

fout.write("Physical Line(1) = {1:"+ str(count_bnd))
if (holes_file != 'none'):
	fout.write(', ')
	for i in range(n_holes-1):
		fout.write(str(hole_nodes[i]*-1) + ", ")
	fout.write(str(-1*hole_nodes[n_holes-1]))	
fout.write(str("};") + "\n")


fout.write("Plane Surface(1) = {1};" + "\n")
fout.write("Physical Surface(1) = {1};" + "\n")

if (lines_file != 'none'):
	# write the embedded lines
	# re-set the count_lns back to what it was before
	count_lns = count_bnd + 1
	for i in range(0,n_lns):
		if (i>0):
			cur_lns_shapeid = shapeid_lns[i]
			prev_lns_shapeid = shapeid_lns[i-1]
			if (cur_lns_shapeid - prev_lns_shapeid < 0.001):
				#fout.write(str(cur_lns_shapeid) + " " + str(prev_lns_shapeid) + " ")
				fout.write(str("Line {") + str(count_lns) + "} In Surface {1};" + "\n")
				count_lns = count_lns + 1
	
# if there are embedded nodes, write them to the file
# embedded nodes should be used in tin applications, not in mesh generation
for i in range(0,n):
	if (is_node_emb[i] == 1):
		fout.write(str("Point {") + str(node[i]) + "} In Surface {1};" + "\n")

# gmsh option to make sure the elements size extend from boundary
# write zero when doing a TIN; write one when doing a mesh!
#fout.write(str("Mesh.CharacteristicLengthExtendFromBoundary = 0;") + "\n")


	
	
	
	
	
	
